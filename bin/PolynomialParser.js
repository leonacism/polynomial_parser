// Generated by Haxe 4.0.0 (git build development @ f3252fcf9)
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe__$Int32_Int32_$Impl_$ = {};
haxe__$Int32_Int32_$Impl_$.__name__ = true;
haxe__$Int32_Int32_$Impl_$.ucompare = function(a,b) {
	if(a < 0) {
		if(b < 0) {
			return ~b - ~a | 0;
		} else {
			return 1;
		}
	}
	if(b < 0) {
		return -1;
	} else {
		return a - b | 0;
	}
};
var haxe__$Int64_Int64_$Impl_$ = {};
haxe__$Int64_Int64_$Impl_$.__name__ = true;
haxe__$Int64_Int64_$Impl_$.toString = function(this1) {
	var i = this1;
	var this_high = 0;
	var this_low = 0;
	if(i.high == this_high && i.low == this_low) {
		return "0";
	}
	var str = "";
	var neg = false;
	if(i.high < 0) {
		neg = true;
	}
	var this2 = new haxe__$Int64__$_$_$Int64(0,10);
	var ten = this2;
	while(true) {
		var this_high1 = 0;
		var this_low1 = 0;
		if(!(i.high != this_high1 || i.low != this_low1)) {
			break;
		}
		var r = haxe__$Int64_Int64_$Impl_$.divMod(i,ten);
		if(r.modulus.high < 0) {
			var x = r.modulus;
			var high = ~x.high;
			var low = -x.low;
			if(low == 0) {
				var ret = high++;
				high = high | 0;
			}
			var this_high2 = high;
			var this_low2 = low;
			str = this_low2 + str;
			var x1 = r.quotient;
			var high1 = ~x1.high;
			var low1 = -x1.low;
			if(low1 == 0) {
				var ret1 = high1++;
				high1 = high1 | 0;
			}
			var this3 = new haxe__$Int64__$_$_$Int64(high1,low1);
			i = this3;
		} else {
			str = r.modulus.low + str;
			i = r.quotient;
		}
	}
	if(neg) {
		str = "-" + str;
	}
	return str;
};
haxe__$Int64_Int64_$Impl_$.divMod = function(dividend,divisor) {
	if(divisor.high == 0) {
		var _g = divisor.low;
		switch(_g) {
		case 0:
			throw new js__$Boot_HaxeError("divide by zero");
		case 1:
			var this1 = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
			var this2 = new haxe__$Int64__$_$_$Int64(0,0);
			return { quotient : this1, modulus : this2};
		}
	}
	var divSign = dividend.high < 0 != divisor.high < 0;
	var modulus;
	if(dividend.high < 0) {
		var high = ~dividend.high;
		var low = -dividend.low;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		var this3 = new haxe__$Int64__$_$_$Int64(high,low);
		modulus = this3;
	} else {
		var this4 = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
		modulus = this4;
	}
	if(divisor.high < 0) {
		var high1 = ~divisor.high;
		var low1 = -divisor.low;
		if(low1 == 0) {
			var ret1 = high1++;
			high1 = high1 | 0;
		}
		var this5 = new haxe__$Int64__$_$_$Int64(high1,low1);
		divisor = this5;
	} else {
		divisor = divisor;
	}
	var this6 = new haxe__$Int64__$_$_$Int64(0,0);
	var quotient = this6;
	var this7 = new haxe__$Int64__$_$_$Int64(0,1);
	var mask = this7;
	while(!(divisor.high < 0)) {
		var v = haxe__$Int32_Int32_$Impl_$.ucompare(divisor.high,modulus.high);
		var cmp = v != 0 ? v : haxe__$Int32_Int32_$Impl_$.ucompare(divisor.low,modulus.low);
		var b = 1;
		b &= 63;
		if(b == 0) {
			var this8 = new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low);
			divisor = this8;
		} else if(b < 32) {
			var this9 = new haxe__$Int64__$_$_$Int64(divisor.high << b | divisor.low >>> 32 - b,divisor.low << b);
			divisor = this9;
		} else {
			var this10 = new haxe__$Int64__$_$_$Int64(divisor.low << b - 32,0);
			divisor = this10;
		}
		var b1 = 1;
		b1 &= 63;
		if(b1 == 0) {
			var this11 = new haxe__$Int64__$_$_$Int64(mask.high,mask.low);
			mask = this11;
		} else if(b1 < 32) {
			var this12 = new haxe__$Int64__$_$_$Int64(mask.high << b1 | mask.low >>> 32 - b1,mask.low << b1);
			mask = this12;
		} else {
			var this13 = new haxe__$Int64__$_$_$Int64(mask.low << b1 - 32,0);
			mask = this13;
		}
		if(cmp >= 0) {
			break;
		}
	}
	while(true) {
		var this_high = 0;
		var this_low = 0;
		if(!(mask.high != this_high || mask.low != this_low)) {
			break;
		}
		var v1 = haxe__$Int32_Int32_$Impl_$.ucompare(modulus.high,divisor.high);
		if((v1 != 0 ? v1 : haxe__$Int32_Int32_$Impl_$.ucompare(modulus.low,divisor.low)) >= 0) {
			var this14 = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
			quotient = this14;
			var high2 = modulus.high - divisor.high | 0;
			var low2 = modulus.low - divisor.low | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(modulus.low,divisor.low) < 0) {
				var ret2 = high2--;
				high2 = high2 | 0;
			}
			var this15 = new haxe__$Int64__$_$_$Int64(high2,low2);
			modulus = this15;
		}
		var b2 = 1;
		b2 &= 63;
		if(b2 == 0) {
			var this16 = new haxe__$Int64__$_$_$Int64(mask.high,mask.low);
			mask = this16;
		} else if(b2 < 32) {
			var this17 = new haxe__$Int64__$_$_$Int64(mask.high >>> b2,mask.high << 32 - b2 | mask.low >>> b2);
			mask = this17;
		} else {
			var this18 = new haxe__$Int64__$_$_$Int64(0,mask.high >>> b2 - 32);
			mask = this18;
		}
		var b3 = 1;
		b3 &= 63;
		if(b3 == 0) {
			var this19 = new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low);
			divisor = this19;
		} else if(b3 < 32) {
			var this20 = new haxe__$Int64__$_$_$Int64(divisor.high >>> b3,divisor.high << 32 - b3 | divisor.low >>> b3);
			divisor = this20;
		} else {
			var this21 = new haxe__$Int64__$_$_$Int64(0,divisor.high >>> b3 - 32);
			divisor = this21;
		}
	}
	if(divSign) {
		var high3 = ~quotient.high;
		var low3 = -quotient.low;
		if(low3 == 0) {
			var ret3 = high3++;
			high3 = high3 | 0;
		}
		var this22 = new haxe__$Int64__$_$_$Int64(high3,low3);
		quotient = this22;
	}
	if(dividend.high < 0) {
		var high4 = ~modulus.high;
		var low4 = -modulus.low;
		if(low4 == 0) {
			var ret4 = high4++;
			high4 = high4 | 0;
		}
		var this23 = new haxe__$Int64__$_$_$Int64(high4,low4);
		modulus = this23;
	}
	return { quotient : quotient, modulus : modulus};
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = true;
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if((o instanceof Array)) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var main_Main = function() { };
main_Main.__name__ = true;
main_Main.main = function() {
	var str = "(x)^2+(-y)^2+z^2-3*(-x)*y+(-3)*y*z+3*z*(-x)";
	var poly = new polynomial_Polynomial(str,["x","y","z"]);
	console.log("Main.hx:8:","[" + str + "]^8 = " + poly.pow(poly,8).toString());
};
var parser_Analyzer = function() {
};
parser_Analyzer.__name__ = true;
parser_Analyzer.prototype = {
	analyze: function(tree,impl) {
		this.stack = [];
		this.impl = impl;
		this.index = 0;
		this.runRPN(tree.toString());
		return this.pop().data;
	}
	,runRPN: function(rpn) {
		var data = rpn.split(" ");
		var _g = 0;
		while(_g < data.length) {
			var s = data[_g];
			++_g;
			switch(s) {
			case "@add":
				this.binOp("@add");
				break;
			case "@div":
				this.binOp("@div");
				break;
			case "@mod":
				this.binOp("@mod");
				break;
			case "@mul":
				this.binOp("@mul");
				break;
			case "@neg":
				this.unOp("@neg");
				break;
			case "@pow":
				this.pow();
				break;
			case "@sub":
				this.binOp("@sub");
				break;
			default:
				this.push(s,this.impl.compile(s));
			}
		}
	}
	,binOp: function(op) {
		var rhs = this.pop();
		var lhs = this.pop();
		var a = lhs.data == null ? lhs.data = this.impl.compile(lhs.name) : lhs.data;
		var b = rhs.data == null ? rhs.data = this.impl.compile(rhs.name) : rhs.data;
		var tmp;
		switch(op) {
		case "@add":
			tmp = this.impl.add(a,b);
			break;
		case "@div":
			tmp = this.impl.div(a,b);
			break;
		case "@mod":
			tmp = this.impl.mod(a,b);
			break;
		case "@mul":
			tmp = this.impl.mul(a,b);
			break;
		case "@sub":
			tmp = this.impl.sub(a,b);
			break;
		default:
			tmp = null;
		}
		this.push("" + Std.string(tmp),tmp);
	}
	,unOp: function(op) {
		var rhs = this.pop();
		var a = rhs.data == null ? rhs.data = this.impl.compile(rhs.name) : rhs.data;
		var tmp = op == "@neg" ? this.impl.scale(a,-1) : null;
		this.push("" + Std.string(tmp),tmp);
	}
	,pow: function() {
		var rhs = this.pop();
		var lhs = this.pop();
		var a = lhs.data == null ? lhs.data = this.impl.compile(lhs.name) : lhs.data;
		var n = Std.parseInt(rhs.name);
		var tmp = this.impl.pow(a,n);
		this.push("" + Std.string(tmp),tmp);
	}
	,push: function(name,data) {
		this.stack.push({ name : name, data : data});
	}
	,pop: function() {
		return this.stack.pop();
	}
};
var parser_Constants = function() { };
parser_Constants.__name__ = true;
parser_Constants.get_KEYWORDS = function() {
	return [];
};
parser_Constants.get_SYMBOLS = function() {
	return ["+","-","*","/","%","^","(",")"];
};
parser_Constants.get_OPERATOR_PRECEDENCES = function() {
	return [["+","-"],["/","%"],["*"]];
};
var parser_Parser = function() {
};
parser_Parser.__name__ = true;
parser_Parser.prototype = {
	parse: function(tokens) {
		var this1 = tokens;
		var i = this1;
		this.tr = { hasNext : function() {
			return i.type != parser_Type.EOF;
		}, next : function() {
			var tmp = i;
			i = i.next;
			return tmp;
		}, peek : function() {
			return i;
		}};
		this.tree = new parser_node_MainNode();
		this.tree.expr = this.parseExpression();
		this.getData(this.tr.next(),parser_Type.EOF);
		return this.tree;
	}
	,parseExpression: function() {
		var lhs = this.parseUnaryExpression();
		return this.parseBinaryExpression(lhs,0);
	}
	,parseBinaryExpression: function(lhs,minPrec) {
		var prec;
		while(true) {
			prec = this.getPrec(this.tr.peek());
			if(!(prec >= minPrec)) {
				break;
			}
			var op;
			var _g = this.getData(this.tr.next(),parser_Type.Symbol(null));
			switch(_g) {
			case "%":
				op = "@mod";
				break;
			case "*":
				op = "@mul";
				break;
			case "+":
				op = "@add";
				break;
			case "-":
				op = "@sub";
				break;
			case "/":
				op = "@div";
				break;
			default:
				throw new js__$Boot_HaxeError("unexpected token : " + this.getData(this.tr.next(),parser_Type.Symbol(null)));
			}
			var rhs = this.parseTermExpression();
			if(this.getPrec(this.tr.peek()) > prec) {
				rhs = this.parseBinaryExpression(rhs,prec + 1);
			}
			var ben = new parser_node_BinaryExpressionNode();
			ben.lhs = lhs;
			ben.op = op;
			ben.rhs = rhs;
			lhs = ben;
		}
		return lhs;
	}
	,getPrec: function(token) {
		var op = this.is(token,parser_Type.Symbol(null)) ? this.getData(this.tr.peek(),parser_Type.Symbol(null)) : null;
		var a = parser_Constants.get_OPERATOR_PRECEDENCES();
		var _g1 = 0;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = 0;
			var _g3 = a[i];
			while(_g2 < _g3.length) {
				var b = _g3[_g2];
				++_g2;
				if(op == b) {
					return i;
				}
			}
		}
		return -1;
	}
	,parseUnaryExpression: function() {
		if(this.is(this.tr.peek(),parser_Type.Symbol("+"))) {
			this.tr.next();
		} else if(this.is(this.tr.peek(),parser_Type.Symbol("-"))) {
			var uen = new parser_node_UnaryExpressionNode();
			this.tr.next();
			uen.op = "@neg";
			uen.rhs = this.parseTermExpression();
			return uen;
		}
		return this.parseTermExpression();
	}
	,parseTermExpression: function() {
		var en = new parser_node_ExpressionNode();
		if(this.is(this.tr.peek(),parser_Type.Identifier(null))) {
			en = this.parseIdentifierExpression();
		} else if(this.is(this.tr.peek(),parser_Type.Symbol("("))) {
			en = this.parseParenExpression();
		} else if(this.is(this.tr.peek(),parser_Type.Number(null))) {
			en = this.parseNumberExpression();
		} else {
			throw new js__$Boot_HaxeError("unexpected token : " + Std.string(this.tr.next()));
		}
		if(this.is(this.tr.peek(),parser_Type.Symbol("^"))) {
			var ten = new parser_node_TermExpressionNode();
			ten.lhs = en;
			this.tr.next();
			ten.op = "@pow";
			ten.rhs = this.parseNumberExpression();
			return ten;
		}
		return en;
	}
	,parseIdentifierExpression: function() {
		var ien = new parser_node_IdentifierExpressionNode();
		ien.identifier = this.getData(this.tr.next(),parser_Type.Identifier(null));
		return ien;
	}
	,parseNumberExpression: function() {
		var nen = new parser_node_NumberExpressionNode();
		nen.number = this.getData(this.tr.next(),parser_Type.Number(null));
		return nen;
	}
	,parseParenExpression: function() {
		this.getData(this.tr.next(),parser_Type.Symbol("("));
		var en = this.parseExpression();
		this.getData(this.tr.next(),parser_Type.Symbol(")"));
		return en;
	}
	,getData: function(token,expected) {
		var _g = token.type;
		switch(_g[1]) {
		case 0:
			var data = _g[2];
			if(expected[1] == 0) {
				var data_ = expected[2];
				if(data == data_ && data_ != null || data_ == null) {
					return data;
				} else {
					throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
				}
			} else {
				throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
			}
			break;
		case 1:
			var data1 = _g[2];
			if(expected[1] == 1) {
				var data_1 = expected[2];
				if(data1 == data_1 && data_1 != null || data_1 == null) {
					return data1;
				} else {
					throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
				}
			} else {
				throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
			}
			break;
		case 2:
			var data2 = _g[2];
			if(expected[1] == 2) {
				var data_2 = expected[2];
				if(data2 == data_2 && data_2 != null || data_2 == null) {
					return data2;
				} else {
					throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
				}
			} else {
				throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
			}
			break;
		case 3:
			var data3 = _g[2];
			if(expected[1] == 3) {
				var data_3 = expected[2];
				if(data3 == data_3 && data_3 != null || data_3 == null) {
					return data3;
				} else {
					throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
				}
			} else {
				throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
			}
			break;
		case 4:
			if(expected[1] == 4) {
				return "EOF";
			} else {
				throw new js__$Boot_HaxeError("unexpected token : " + Std.string(token));
			}
			break;
		}
	}
	,is: function(token,expected) {
		var _g = token.type;
		switch(_g[1]) {
		case 0:
			var data = _g[2];
			if(expected[1] == 0) {
				var data_ = expected[2];
				if(data == data_ && data_ != null || data_ == null) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 1:
			var data1 = _g[2];
			if(expected[1] == 1) {
				var data_1 = expected[2];
				if(data1 == data_1 && data_1 != null || data_1 == null) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 2:
			var data2 = _g[2];
			if(expected[1] == 2) {
				var data_2 = expected[2];
				if(data2 == data_2 && data_2 != null || data_2 == null) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			var data3 = _g[2];
			if(expected[1] == 3) {
				var data_3 = expected[2];
				if(data3 == data_3 && data_3 != null || data_3 == null) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(expected[1] == 4) {
				return true;
			} else {
				return false;
			}
			break;
		}
	}
};
var parser__$StringReader_StringReader_$Impl_$ = {};
parser__$StringReader_StringReader_$Impl_$.__name__ = true;
parser__$StringReader_StringReader_$Impl_$._new = function(data) {
	var this1 = data;
	return this1;
};
parser__$StringReader_StringReader_$Impl_$.to = function(this1) {
	var i = 0;
	return { hasNext : function() {
		return i < this1.length;
	}, next : function() {
		i += 1;
		return this1.charAt(i - 1);
	}, peek : function() {
		return this1.charAt(i);
	}};
};
var parser_Type = { __ename__ : true, __constructs__ : ["Number","Identifier","Keyword","Symbol","EOF"] };
parser_Type.Number = function(data) { var $x = ["Number",0,data]; $x.__enum__ = parser_Type; return $x; };
parser_Type.Identifier = function(data) { var $x = ["Identifier",1,data]; $x.__enum__ = parser_Type; return $x; };
parser_Type.Keyword = function(data) { var $x = ["Keyword",2,data]; $x.__enum__ = parser_Type; return $x; };
parser_Type.Symbol = function(data) { var $x = ["Symbol",3,data]; $x.__enum__ = parser_Type; return $x; };
parser_Type.EOF = ["EOF",4];
parser_Type.EOF.__enum__ = parser_Type;
var parser_Token = function(type) {
	this.type = type;
};
parser_Token.__name__ = true;
parser_Token.prototype = {
	toString: function() {
		var _g = this.type;
		switch(_g[1]) {
		case 0:
			var data = _g[2];
			return "[ num : " + data + " ]";
		case 1:
			var data1 = _g[2];
			return "[ identifier : " + data1 + " ]";
		case 2:
			var data2 = _g[2];
			return "[ keyword : " + data2 + " ]";
		case 3:
			var data3 = _g[2];
			return "[ symbol : " + data3 + " ]";
		case 4:
			return "[ EOF ]";
		}
	}
};
var parser__$TokenReader_TokenReader_$Impl_$ = {};
parser__$TokenReader_TokenReader_$Impl_$.__name__ = true;
parser__$TokenReader_TokenReader_$Impl_$._new = function(token) {
	var this1 = token;
	return this1;
};
parser__$TokenReader_TokenReader_$Impl_$.to = function(this1) {
	var i = this1;
	return { hasNext : function() {
		return i.type != parser_Type.EOF;
	}, next : function() {
		var tmp = i;
		i = i.next;
		return tmp;
	}, peek : function() {
		return i;
	}};
};
var parser_Tokenizer = function() {
};
parser_Tokenizer.__name__ = true;
parser_Tokenizer.prototype = {
	tokenize: function(src) {
		var this1 = src;
		var this2 = this1;
		var i = 0;
		this.sr = { hasNext : function() {
			return i < this2.length;
		}, next : function() {
			i += 1;
			return this2.charAt(i - 1);
		}, peek : function() {
			return this2.charAt(i);
		}};
		this.tokens = null;
		while(this.sr.hasNext()) {
			while(true) {
				var s = this.sr.peek();
				if(!new EReg("[\t\r\n ]","").match(s)) {
					break;
				}
				this.sr.next();
			}
			var s1 = this.sr.peek();
			if(new EReg("[0-9]","").match(s1)) {
				var s2 = "";
				while(true) {
					var s3 = this.sr.peek();
					if(!new EReg("[0-9]","").match(s3)) {
						break;
					}
					s2 += this.sr.next();
				}
				var s4 = this.sr.peek();
				if(new EReg("[a-zA-Z_\\$]","").match(s4)) {
					throw new js__$Boot_HaxeError("invalid number format : " + (s2 + this.sr.peek()));
				} else {
					var token = new parser_Token(parser_Type.Number(s2));
					this.lastToken = this.tokens != null ? this.lastToken.next = token : this.tokens = token;
				}
			} else {
				var s5 = this.sr.peek();
				if(new EReg("[a-zA-Z_\\$]","").match(s5)) {
					var s6 = "";
					while(true) {
						var tmp;
						var s7 = this.sr.peek();
						if(!new EReg("[0-9]","").match(s7)) {
							var s8 = this.sr.peek();
							tmp = new EReg("[a-zA-Z_\\$]","").match(s8);
						} else {
							tmp = true;
						}
						if(!tmp) {
							break;
						}
						s6 += this.sr.next();
					}
					var b = false;
					var _g = 0;
					var _g1 = parser_Constants.get_KEYWORDS();
					while(_g < _g1.length) {
						var k = _g1[_g];
						++_g;
						if(s6 == k) {
							b = true;
							break;
						}
					}
					if(b) {
						var token1 = new parser_Token(parser_Type.Keyword(s6));
						this.lastToken = this.tokens != null ? this.lastToken.next = token1 : this.tokens = token1;
					} else {
						var token2 = new parser_Token(parser_Type.Identifier(s6));
						this.lastToken = this.tokens != null ? this.lastToken.next = token2 : this.tokens = token2;
					}
				} else {
					var s9 = "";
					var b1 = true;
					while(b1) {
						var tmp1 = s9 + this.sr.peek();
						b1 = false;
						var _g2 = 0;
						var _g11 = parser_Constants.get_SYMBOLS();
						while(_g2 < _g11.length) {
							var m = _g11[_g2];
							++_g2;
							if(tmp1 == HxOverrides.substr(m,0,tmp1.length)) {
								s9 += this.sr.next();
								b1 = this.sr.hasNext();
								break;
							}
						}
					}
					var b2 = false;
					var _g3 = 0;
					var _g12 = parser_Constants.get_SYMBOLS();
					while(_g3 < _g12.length) {
						var m1 = _g12[_g3];
						++_g3;
						if(s9 == m1) {
							b2 = true;
							break;
						}
					}
					if(b2) {
						var token3 = new parser_Token(parser_Type.Symbol(s9));
						this.lastToken = this.tokens != null ? this.lastToken.next = token3 : this.tokens = token3;
					} else {
						throw new js__$Boot_HaxeError("invalid symbol format : " + (s9 + this.sr.next()));
					}
				}
			}
		}
		var token4 = new parser_Token(parser_Type.EOF);
		this.lastToken = this.tokens != null ? this.lastToken.next = token4 : this.tokens = token4;
		return this.tokens;
	}
	,readToken: function() {
		while(true) {
			var s = this.sr.peek();
			if(!new EReg("[\t\r\n ]","").match(s)) {
				break;
			}
			this.sr.next();
		}
		var s1 = this.sr.peek();
		if(new EReg("[0-9]","").match(s1)) {
			var s2 = "";
			while(true) {
				var s3 = this.sr.peek();
				if(!new EReg("[0-9]","").match(s3)) {
					break;
				}
				s2 += this.sr.next();
			}
			var s4 = this.sr.peek();
			if(new EReg("[a-zA-Z_\\$]","").match(s4)) {
				throw new js__$Boot_HaxeError("invalid number format : " + (s2 + this.sr.peek()));
			} else {
				var token = new parser_Token(parser_Type.Number(s2));
				this.lastToken = this.tokens != null ? this.lastToken.next = token : this.tokens = token;
			}
		} else {
			var s5 = this.sr.peek();
			if(new EReg("[a-zA-Z_\\$]","").match(s5)) {
				var s6 = "";
				while(true) {
					var tmp;
					var s7 = this.sr.peek();
					if(!new EReg("[0-9]","").match(s7)) {
						var s8 = this.sr.peek();
						tmp = new EReg("[a-zA-Z_\\$]","").match(s8);
					} else {
						tmp = true;
					}
					if(!tmp) {
						break;
					}
					s6 += this.sr.next();
				}
				var b = false;
				var _g = 0;
				var _g1 = parser_Constants.get_KEYWORDS();
				while(_g < _g1.length) {
					var k = _g1[_g];
					++_g;
					if(s6 == k) {
						b = true;
						break;
					}
				}
				if(b) {
					var token1 = new parser_Token(parser_Type.Keyword(s6));
					this.lastToken = this.tokens != null ? this.lastToken.next = token1 : this.tokens = token1;
				} else {
					var token2 = new parser_Token(parser_Type.Identifier(s6));
					this.lastToken = this.tokens != null ? this.lastToken.next = token2 : this.tokens = token2;
				}
			} else {
				var s9 = "";
				var b1 = true;
				while(b1) {
					var tmp1 = s9 + this.sr.peek();
					b1 = false;
					var _g2 = 0;
					var _g11 = parser_Constants.get_SYMBOLS();
					while(_g2 < _g11.length) {
						var m = _g11[_g2];
						++_g2;
						if(tmp1 == HxOverrides.substr(m,0,tmp1.length)) {
							s9 += this.sr.next();
							b1 = this.sr.hasNext();
							break;
						}
					}
				}
				var b2 = false;
				var _g3 = 0;
				var _g12 = parser_Constants.get_SYMBOLS();
				while(_g3 < _g12.length) {
					var m1 = _g12[_g3];
					++_g3;
					if(s9 == m1) {
						b2 = true;
						break;
					}
				}
				if(b2) {
					var token3 = new parser_Token(parser_Type.Symbol(s9));
					this.lastToken = this.tokens != null ? this.lastToken.next = token3 : this.tokens = token3;
				} else {
					throw new js__$Boot_HaxeError("invalid symbol format : " + (s9 + this.sr.next()));
				}
			}
		}
	}
	,appendToken: function(token) {
		if(this.tokens != null) {
			this.lastToken = this.lastToken.next = token;
		} else {
			this.lastToken = this.tokens = token;
		}
	}
	,isSpace: function(s) {
		return new EReg("[\t\r\n ]","").match(s);
	}
	,isNumber: function(s) {
		return new EReg("[0-9]","").match(s);
	}
	,isLetter: function(s) {
		return new EReg("[a-zA-Z_\\$]","").match(s);
	}
	,isKeyword: function(s) {
		var b = false;
		var _g = 0;
		var _g1 = parser_Constants.get_KEYWORDS();
		while(_g < _g1.length) {
			var k = _g1[_g];
			++_g;
			if(s == k) {
				b = true;
				break;
			}
		}
		return b;
	}
	,isSymbol: function(s) {
		var b = false;
		var _g = 0;
		var _g1 = parser_Constants.get_SYMBOLS();
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(s == m) {
				b = true;
				break;
			}
		}
		return b;
	}
};
var parser_node_INode = function() { };
parser_node_INode.__name__ = true;
var parser_node_ExpressionNode = function() {
};
parser_node_ExpressionNode.__name__ = true;
parser_node_ExpressionNode.__interfaces__ = [parser_node_INode];
parser_node_ExpressionNode.prototype = {
	dumpRPN: function() {
		throw new js__$Boot_HaxeError("Not Implemented.");
	}
};
var parser_node_BinaryExpressionNode = function() {
	parser_node_ExpressionNode.call(this);
};
parser_node_BinaryExpressionNode.__name__ = true;
parser_node_BinaryExpressionNode.__super__ = parser_node_ExpressionNode;
parser_node_BinaryExpressionNode.prototype = $extend(parser_node_ExpressionNode.prototype,{
	dumpRPN: function() {
		return "" + this.lhs.dumpRPN() + " " + this.rhs.dumpRPN() + " " + this.op;
	}
});
var parser_node_IdentifierExpressionNode = function() {
	parser_node_ExpressionNode.call(this);
};
parser_node_IdentifierExpressionNode.__name__ = true;
parser_node_IdentifierExpressionNode.__super__ = parser_node_ExpressionNode;
parser_node_IdentifierExpressionNode.prototype = $extend(parser_node_ExpressionNode.prototype,{
	dumpRPN: function() {
		return this.identifier;
	}
});
var parser_node_MainNode = function() {
};
parser_node_MainNode.__name__ = true;
parser_node_MainNode.__interfaces__ = [parser_node_INode];
parser_node_MainNode.prototype = {
	toString: function() {
		return this.expr.dumpRPN();
	}
};
var parser_node_NumberExpressionNode = function() {
	parser_node_ExpressionNode.call(this);
};
parser_node_NumberExpressionNode.__name__ = true;
parser_node_NumberExpressionNode.__super__ = parser_node_ExpressionNode;
parser_node_NumberExpressionNode.prototype = $extend(parser_node_ExpressionNode.prototype,{
	dumpRPN: function() {
		return this.number;
	}
});
var parser_node_TermExpressionNode = function() {
	parser_node_ExpressionNode.call(this);
};
parser_node_TermExpressionNode.__name__ = true;
parser_node_TermExpressionNode.__super__ = parser_node_ExpressionNode;
parser_node_TermExpressionNode.prototype = $extend(parser_node_ExpressionNode.prototype,{
	dumpRPN: function() {
		return "" + this.lhs.dumpRPN() + " " + this.rhs.dumpRPN() + " " + this.op;
	}
});
var parser_node_UnaryExpressionNode = function() {
	parser_node_ExpressionNode.call(this);
};
parser_node_UnaryExpressionNode.__name__ = true;
parser_node_UnaryExpressionNode.__super__ = parser_node_ExpressionNode;
parser_node_UnaryExpressionNode.prototype = $extend(parser_node_ExpressionNode.prototype,{
	dumpRPN: function() {
		return "" + this.rhs.dumpRPN() + " " + this.op;
	}
});
var polynomial_Impl = function() { };
polynomial_Impl.__name__ = true;
var polynomial_Polynomial = function(expr,variables) {
	var t_lastToken;
	var p = new parser_Parser();
	var a = new parser_Analyzer();
	var this1 = expr;
	var this2 = this1;
	var i = 0;
	var t_sr_hasNext = function() {
		return i < this2.length;
	};
	var t_sr_next = function() {
		i += 1;
		return this2.charAt(i - 1);
	};
	var t_sr_peek = function() {
		return this2.charAt(i);
	};
	var t_tokens = null;
	while(t_sr_hasNext()) {
		while(true) {
			var s = t_sr_peek();
			if(!new EReg("[\t\r\n ]","").match(s)) {
				break;
			}
			t_sr_next();
		}
		var s1 = t_sr_peek();
		if(new EReg("[0-9]","").match(s1)) {
			var s2 = "";
			while(true) {
				var s3 = t_sr_peek();
				if(!new EReg("[0-9]","").match(s3)) {
					break;
				}
				s2 += t_sr_next();
			}
			var s4 = t_sr_peek();
			if(new EReg("[a-zA-Z_\\$]","").match(s4)) {
				throw new js__$Boot_HaxeError("invalid number format : " + (s2 + t_sr_peek()));
			} else {
				var token = new parser_Token(parser_Type.Number(s2));
				if(t_tokens != null) {
					t_lastToken = t_lastToken.next = token;
				} else {
					t_tokens = token;
					t_lastToken = t_tokens;
				}
			}
		} else {
			var s5 = t_sr_peek();
			if(new EReg("[a-zA-Z_\\$]","").match(s5)) {
				var s6 = "";
				while(true) {
					var tmp;
					var s7 = t_sr_peek();
					if(!new EReg("[0-9]","").match(s7)) {
						var s8 = t_sr_peek();
						tmp = new EReg("[a-zA-Z_\\$]","").match(s8);
					} else {
						tmp = true;
					}
					if(!tmp) {
						break;
					}
					s6 += t_sr_next();
				}
				var b = false;
				var _g = 0;
				var _g1 = parser_Constants.get_KEYWORDS();
				while(_g < _g1.length) {
					var k = _g1[_g];
					++_g;
					if(s6 == k) {
						b = true;
						break;
					}
				}
				if(b) {
					var token1 = new parser_Token(parser_Type.Keyword(s6));
					if(t_tokens != null) {
						t_lastToken = t_lastToken.next = token1;
					} else {
						t_tokens = token1;
						t_lastToken = t_tokens;
					}
				} else {
					var token2 = new parser_Token(parser_Type.Identifier(s6));
					if(t_tokens != null) {
						t_lastToken = t_lastToken.next = token2;
					} else {
						t_tokens = token2;
						t_lastToken = t_tokens;
					}
				}
			} else {
				var s9 = "";
				var b1 = true;
				while(b1) {
					var tmp1 = s9 + t_sr_peek();
					b1 = false;
					var _g2 = 0;
					var _g11 = parser_Constants.get_SYMBOLS();
					while(_g2 < _g11.length) {
						var m = _g11[_g2];
						++_g2;
						if(tmp1 == HxOverrides.substr(m,0,tmp1.length)) {
							s9 += t_sr_next();
							b1 = t_sr_hasNext();
							break;
						}
					}
				}
				var b2 = false;
				var _g3 = 0;
				var _g12 = parser_Constants.get_SYMBOLS();
				while(_g3 < _g12.length) {
					var m1 = _g12[_g3];
					++_g3;
					if(s9 == m1) {
						b2 = true;
						break;
					}
				}
				if(b2) {
					var token3 = new parser_Token(parser_Type.Symbol(s9));
					if(t_tokens != null) {
						t_lastToken = t_lastToken.next = token3;
					} else {
						t_tokens = token3;
						t_lastToken = t_tokens;
					}
				} else {
					throw new js__$Boot_HaxeError("invalid symbol format : " + (s9 + t_sr_next()));
				}
			}
		}
	}
	var token4 = new parser_Token(parser_Type.EOF);
	if(t_tokens != null) {
		t_lastToken = t_lastToken.next = token4;
	} else {
		t_tokens = token4;
		t_lastToken = t_tokens;
	}
	this.tree = p.parse(t_tokens);
	this.impl = new polynomial_PolynomialImpl(variables);
	this.data = a.analyze(this.tree,this.impl);
	this.expr = this.impl.dumpIN(this.data);
	this.variables = this.impl.variables;
};
polynomial_Polynomial.__name__ = true;
polynomial_Polynomial.prototype = {
	add: function(p1,p2) {
		var tmp = [];
		var _g = 0;
		var _g1 = p1.variables;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			var f = true;
			var _g2 = 0;
			while(_g2 < tmp.length) {
				var s = tmp[_g2];
				++_g2;
				if(s == s1) {
					f = false;
				}
			}
			if(f) {
				tmp.push(s1);
			}
		}
		var _g3 = 0;
		var _g11 = p2.variables;
		while(_g3 < _g11.length) {
			var s2 = _g11[_g3];
			++_g3;
			var f1 = true;
			var _g21 = 0;
			while(_g21 < tmp.length) {
				var s3 = tmp[_g21];
				++_g21;
				if(s3 == s2) {
					f1 = false;
				}
			}
			if(f1) {
				tmp.push(s2);
			}
		}
		this.impl.variables = tmp;
		if(p1.variables.length != this.impl.variables.length) {
			p1 = new polynomial_Polynomial(p1.expr,this.impl.variables);
		}
		if(p2.variables.length != this.impl.variables.length) {
			p2 = new polynomial_Polynomial(p2.expr,this.impl.variables);
		}
		this.data = this.impl.add(p1.data,p2.data);
		this.expr = this.impl.dumpIN(this.data);
		this.variables = this.impl.variables;
		return this;
	}
	,sub: function(p1,p2) {
		var tmp = [];
		var _g = 0;
		var _g1 = p1.variables;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			var f = true;
			var _g2 = 0;
			while(_g2 < tmp.length) {
				var s = tmp[_g2];
				++_g2;
				if(s == s1) {
					f = false;
				}
			}
			if(f) {
				tmp.push(s1);
			}
		}
		var _g3 = 0;
		var _g11 = p2.variables;
		while(_g3 < _g11.length) {
			var s2 = _g11[_g3];
			++_g3;
			var f1 = true;
			var _g21 = 0;
			while(_g21 < tmp.length) {
				var s3 = tmp[_g21];
				++_g21;
				if(s3 == s2) {
					f1 = false;
				}
			}
			if(f1) {
				tmp.push(s2);
			}
		}
		this.impl.variables = tmp;
		if(p1.variables.length != this.impl.variables.length) {
			p1 = new polynomial_Polynomial(p1.expr,this.impl.variables);
		}
		if(p2.variables.length != this.impl.variables.length) {
			p2 = new polynomial_Polynomial(p2.expr,this.impl.variables);
		}
		this.data = this.impl.sub(p1.data,p2.data);
		this.expr = this.impl.dumpIN(this.data);
		this.variables = this.impl.variables;
		return this;
	}
	,mul: function(p1,p2) {
		var tmp = [];
		var _g = 0;
		var _g1 = p1.variables;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			var f = true;
			var _g2 = 0;
			while(_g2 < tmp.length) {
				var s = tmp[_g2];
				++_g2;
				if(s == s1) {
					f = false;
				}
			}
			if(f) {
				tmp.push(s1);
			}
		}
		var _g3 = 0;
		var _g11 = p2.variables;
		while(_g3 < _g11.length) {
			var s2 = _g11[_g3];
			++_g3;
			var f1 = true;
			var _g21 = 0;
			while(_g21 < tmp.length) {
				var s3 = tmp[_g21];
				++_g21;
				if(s3 == s2) {
					f1 = false;
				}
			}
			if(f1) {
				tmp.push(s2);
			}
		}
		this.impl.variables = tmp;
		if(p1.variables.length != this.impl.variables.length) {
			p1 = new polynomial_Polynomial(p1.expr,this.impl.variables);
		}
		if(p2.variables.length != this.impl.variables.length) {
			p2 = new polynomial_Polynomial(p2.expr,this.impl.variables);
		}
		this.data = this.impl.mul(p1.data,p2.data);
		this.expr = this.impl.dumpIN(this.data);
		this.variables = this.impl.variables;
		return this;
	}
	,pow: function(p,n) {
		var tmp = [];
		var _g = 0;
		var _g1 = p.variables;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			var f = true;
			var _g2 = 0;
			while(_g2 < tmp.length) {
				var s = tmp[_g2];
				++_g2;
				if(s == s1) {
					f = false;
				}
			}
			if(f) {
				tmp.push(s1);
			}
		}
		this.impl.variables = tmp;
		if(p.variables.length != this.impl.variables.length) {
			p = new polynomial_Polynomial(p.expr,this.impl.variables);
		}
		this.data = this.impl.pow(p.data,n);
		this.expr = this.impl.dumpIN(this.data);
		this.variables = this.impl.variables;
		return this;
	}
	,scale: function(p,n) {
		var tmp = [];
		var _g = 0;
		var _g1 = p.variables;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			var f = true;
			var _g2 = 0;
			while(_g2 < tmp.length) {
				var s = tmp[_g2];
				++_g2;
				if(s == s1) {
					f = false;
				}
			}
			if(f) {
				tmp.push(s1);
			}
		}
		this.impl.variables = tmp;
		if(p.variables.length != this.impl.variables.length) {
			p = new polynomial_Polynomial(p.expr,this.impl.variables);
		}
		this.data = this.impl.scale(p.data,n);
		this.expr = this.impl.dumpIN(this.data);
		this.variables = this.impl.variables;
		return this;
	}
	,toString: function() {
		return this.expr;
	}
};
var polynomial_PolynomialImpl = function(variables) {
	this.variables = variables;
};
polynomial_PolynomialImpl.__name__ = true;
polynomial_PolynomialImpl.__interfaces__ = [polynomial_Impl];
polynomial_PolynomialImpl.prototype = {
	add: function(a,b) {
		var tmp = new haxe_ds_ObjectMap();
		var k = a.keys();
		while(k.hasNext()) {
			var k1 = k.next();
			var v = a.h[k1.__id__];
			tmp.set(k1,v);
		}
		var k2 = b.keys();
		while(k2.hasNext()) {
			var k3 = k2.next();
			var v1 = b.h[k3.__id__];
			var f = true;
			var l = tmp.keys();
			while(l.hasNext()) {
				var l1 = l.next();
				if(this.equals(k3,l1)) {
					var a1 = tmp.h[l1.__id__];
					var high = a1.high + v1.high | 0;
					var low = a1.low + v1.low | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low,a1.low) < 0) {
						var ret = high++;
						high = high | 0;
					}
					var this1 = new haxe__$Int64__$_$_$Int64(high,low);
					tmp.set(l1,this1);
					f = false;
				}
			}
			if(f) {
				tmp.set(k3,v1);
			}
		}
		var k4 = tmp.keys();
		while(k4.hasNext()) {
			var k5 = k4.next();
			var a2 = tmp.h[k5.__id__];
			var this_high = 0;
			var this_low = 0;
			if(a2.high == this_high && a2.low == this_low) {
				tmp.remove(k5);
			}
		}
		if(!tmp.keys().hasNext()) {
			var _g = [];
			var _g2 = 0;
			var _g1 = this.variables.length;
			while(_g2 < _g1) {
				var i = _g2++;
				_g.push(0);
			}
			var this2 = new haxe__$Int64__$_$_$Int64(0,0);
			tmp.set(_g,this2);
		}
		return tmp;
	}
	,sub: function(a,b) {
		var tmp = new haxe_ds_ObjectMap();
		var k = a.keys();
		while(k.hasNext()) {
			var k1 = k.next();
			var v = a.h[k1.__id__];
			tmp.set(k1,v);
		}
		var k2 = b.keys();
		while(k2.hasNext()) {
			var k3 = k2.next();
			var x = b.h[k3.__id__];
			var high = ~x.high;
			var low = -x.low;
			if(low == 0) {
				var ret = high++;
				high = high | 0;
			}
			var this1 = new haxe__$Int64__$_$_$Int64(high,low);
			var v1 = this1;
			var f = true;
			var l = tmp.keys();
			while(l.hasNext()) {
				var l1 = l.next();
				if(this.equals(k3,l1)) {
					var a1 = tmp.h[l1.__id__];
					var high1 = a1.high + v1.high | 0;
					var low1 = a1.low + v1.low | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low1,a1.low) < 0) {
						var ret1 = high1++;
						high1 = high1 | 0;
					}
					var this2 = new haxe__$Int64__$_$_$Int64(high1,low1);
					tmp.set(l1,this2);
					f = false;
				}
			}
			if(f) {
				tmp.set(k3,v1);
			}
		}
		var k4 = tmp.keys();
		while(k4.hasNext()) {
			var k5 = k4.next();
			var a2 = tmp.h[k5.__id__];
			var this_high = 0;
			var this_low = 0;
			if(a2.high == this_high && a2.low == this_low) {
				tmp.remove(k5);
			}
		}
		if(!tmp.keys().hasNext()) {
			var _g = [];
			var _g2 = 0;
			var _g1 = this.variables.length;
			while(_g2 < _g1) {
				var i = _g2++;
				_g.push(0);
			}
			var this3 = new haxe__$Int64__$_$_$Int64(0,0);
			tmp.set(_g,this3);
		}
		return tmp;
	}
	,mul: function(a,b) {
		var tmp = new haxe_ds_ObjectMap();
		var k1 = a.keys();
		while(k1.hasNext()) {
			var k11 = k1.next();
			var k2 = b.keys();
			while(k2.hasNext()) {
				var k21 = k2.next();
				var _g = [];
				var _g2 = 0;
				var _g1 = this.variables.length;
				while(_g2 < _g1) {
					var i = _g2++;
					_g.push(k11[i] + k21[i]);
				}
				var k = _g;
				var a1 = a.h[k11.__id__];
				var b1 = b.h[k21.__id__];
				var mask = 65535;
				var al = a1.low & mask;
				var ah = a1.low >>> 16;
				var bl = b1.low & mask;
				var bh = b1.low >>> 16;
				var p00 = haxe__$Int32_Int32_$Impl_$._mul(al,bl);
				var p10 = haxe__$Int32_Int32_$Impl_$._mul(ah,bl);
				var p01 = haxe__$Int32_Int32_$Impl_$._mul(al,bh);
				var p11 = haxe__$Int32_Int32_$Impl_$._mul(ah,bh);
				var low = p00;
				var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
				p01 = p01 << 16;
				low = low + p01 | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(low,p01) < 0) {
					var ret = high++;
					high = high | 0;
				}
				p10 = p10 << 16;
				low = low + p10 | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(low,p10) < 0) {
					var ret1 = high++;
					high = high | 0;
				}
				high = high + (haxe__$Int32_Int32_$Impl_$._mul(a1.low,b1.high) + haxe__$Int32_Int32_$Impl_$._mul(a1.high,b1.low) | 0) | 0;
				var this1 = new haxe__$Int64__$_$_$Int64(high,low);
				var v = this1;
				var f = true;
				var l = tmp.keys();
				while(l.hasNext()) {
					var l1 = l.next();
					if(this.equals(k,l1)) {
						var a2 = tmp.h[l1.__id__];
						var high1 = a2.high + v.high | 0;
						var low1 = a2.low + v.low | 0;
						if(haxe__$Int32_Int32_$Impl_$.ucompare(low1,a2.low) < 0) {
							var ret2 = high1++;
							high1 = high1 | 0;
						}
						var this2 = new haxe__$Int64__$_$_$Int64(high1,low1);
						tmp.set(l1,this2);
						f = false;
					}
				}
				if(f) {
					tmp.set(k,v);
				}
			}
		}
		var k3 = tmp.keys();
		while(k3.hasNext()) {
			var k4 = k3.next();
			var a3 = tmp.h[k4.__id__];
			var this_high = 0;
			var this_low = 0;
			if(a3.high == this_high && a3.low == this_low) {
				tmp.remove(k4);
			}
		}
		if(!tmp.keys().hasNext()) {
			var _g3 = [];
			var _g21 = 0;
			var _g11 = this.variables.length;
			while(_g21 < _g11) {
				var i1 = _g21++;
				_g3.push(0);
			}
			var this3 = new haxe__$Int64__$_$_$Int64(0,0);
			tmp.set(_g3,this3);
		}
		return tmp;
	}
	,div: function(a,b) {
		throw new js__$Boot_HaxeError("Not Implemented.");
	}
	,mod: function(a,b) {
		throw new js__$Boot_HaxeError("Not Implemented.");
	}
	,pow: function(a,n) {
		var tmp = new haxe_ds_ObjectMap();
		var m = 0;
		var i = a.iterator();
		while(i.hasNext()) {
			var i1 = i.next();
			++m;
		}
		var _g = [];
		var _g2 = 0;
		var _g1 = m;
		while(_g2 < _g1) {
			var i2 = _g2++;
			_g.push(0);
		}
		var c = _g;
		c[0] = n;
		while(true) {
			var _g11 = [];
			var _g3 = 0;
			var _g21 = this.variables.length;
			while(_g3 < _g21) {
				var i3 = _g3++;
				_g11.push(0);
			}
			var k = _g11;
			var this1 = new haxe__$Int64__$_$_$Int64(0,1);
			var v = this1;
			var j = 0;
			var k1 = a.keys();
			while(k1.hasNext()) {
				var k11 = k1.next();
				var _g31 = 0;
				var _g22 = this.variables.length;
				while(_g31 < _g22) {
					var i4 = _g31++;
					k[i4] += c[j] * k11[i4];
				}
				var _g32 = 0;
				var _g23 = c[j];
				while(_g32 < _g23) {
					var i5 = _g32++;
					var b = a.h[k11.__id__];
					var mask = 65535;
					var al = v.low & mask;
					var ah = v.low >>> 16;
					var bl = b.low & mask;
					var bh = b.low >>> 16;
					var p00 = haxe__$Int32_Int32_$Impl_$._mul(al,bl);
					var p10 = haxe__$Int32_Int32_$Impl_$._mul(ah,bl);
					var p01 = haxe__$Int32_Int32_$Impl_$._mul(al,bh);
					var p11 = haxe__$Int32_Int32_$Impl_$._mul(ah,bh);
					var low = p00;
					var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
					p01 = p01 << 16;
					low = low + p01 | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low,p01) < 0) {
						var ret = high++;
						high = high | 0;
					}
					p10 = p10 << 16;
					low = low + p10 | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low,p10) < 0) {
						var ret1 = high++;
						high = high | 0;
					}
					high = high + (haxe__$Int32_Int32_$Impl_$._mul(v.low,b.high) + haxe__$Int32_Int32_$Impl_$._mul(v.high,b.low) | 0) | 0;
					var this2 = new haxe__$Int64__$_$_$Int64(high,low);
					v = this2;
				}
				++j;
			}
			var this_high = n >> 31;
			var this_low = n;
			var r;
			var this_high1 = 0;
			var this_low1 = 0;
			var v1 = this_high - this_high1 | 0;
			v1 = v1 != 0 ? v1 : haxe__$Int32_Int32_$Impl_$.ucompare(this_low,this_low1);
			if((this_high < 0 ? this_high1 < 0 ? v1 : -1 : this_high1 >= 0 ? v1 : 1) <= 0) {
				var this3 = new haxe__$Int64__$_$_$Int64(0,1);
				r = this3;
			} else {
				var this_high2 = 0;
				var this_low2 = 1;
				var high1 = this_high - this_high2 | 0;
				var low1 = this_low - this_low2 | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(this_low,this_low2) < 0) {
					var ret2 = high1--;
					high1 = high1 | 0;
				}
				var this4 = new haxe__$Int64__$_$_$Int64(high1,low1);
				var b1 = this.fact(this4);
				var mask1 = 65535;
				var al1 = this_low & mask1;
				var ah1 = this_low >>> 16;
				var bl1 = b1.low & mask1;
				var bh1 = b1.low >>> 16;
				var p001 = haxe__$Int32_Int32_$Impl_$._mul(al1,bl1);
				var p101 = haxe__$Int32_Int32_$Impl_$._mul(ah1,bl1);
				var p011 = haxe__$Int32_Int32_$Impl_$._mul(al1,bh1);
				var p111 = haxe__$Int32_Int32_$Impl_$._mul(ah1,bh1);
				var low2 = p001;
				var high2 = (p111 + (p011 >>> 16) | 0) + (p101 >>> 16) | 0;
				p011 = p011 << 16;
				low2 = low2 + p011 | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(low2,p011) < 0) {
					var ret3 = high2++;
					high2 = high2 | 0;
				}
				p101 = p101 << 16;
				low2 = low2 + p101 | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(low2,p101) < 0) {
					var ret4 = high2++;
					high2 = high2 | 0;
				}
				high2 = high2 + (haxe__$Int32_Int32_$Impl_$._mul(this_low,b1.high) + haxe__$Int32_Int32_$Impl_$._mul(this_high,b1.low) | 0) | 0;
				var this5 = new haxe__$Int64__$_$_$Int64(high2,low2);
				r = this5;
			}
			var _g24 = 0;
			while(_g24 < c.length) {
				var i6 = c[_g24];
				++_g24;
				var this_high3 = i6 >> 31;
				var this_low3 = i6;
				var b2;
				var this_high4 = 0;
				var this_low4 = 0;
				var v2 = this_high3 - this_high4 | 0;
				v2 = v2 != 0 ? v2 : haxe__$Int32_Int32_$Impl_$.ucompare(this_low3,this_low4);
				if((this_high3 < 0 ? this_high4 < 0 ? v2 : -1 : this_high4 >= 0 ? v2 : 1) <= 0) {
					var this6 = new haxe__$Int64__$_$_$Int64(0,1);
					b2 = this6;
				} else {
					var this_high5 = 0;
					var this_low5 = 1;
					var high3 = this_high3 - this_high5 | 0;
					var low3 = this_low3 - this_low5 | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(this_low3,this_low5) < 0) {
						var ret5 = high3--;
						high3 = high3 | 0;
					}
					var this7 = new haxe__$Int64__$_$_$Int64(high3,low3);
					var b3 = this.fact(this7);
					var mask2 = 65535;
					var al2 = this_low3 & mask2;
					var ah2 = this_low3 >>> 16;
					var bl2 = b3.low & mask2;
					var bh2 = b3.low >>> 16;
					var p002 = haxe__$Int32_Int32_$Impl_$._mul(al2,bl2);
					var p102 = haxe__$Int32_Int32_$Impl_$._mul(ah2,bl2);
					var p012 = haxe__$Int32_Int32_$Impl_$._mul(al2,bh2);
					var p112 = haxe__$Int32_Int32_$Impl_$._mul(ah2,bh2);
					var low4 = p002;
					var high4 = (p112 + (p012 >>> 16) | 0) + (p102 >>> 16) | 0;
					p012 = p012 << 16;
					low4 = low4 + p012 | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low4,p012) < 0) {
						var ret6 = high4++;
						high4 = high4 | 0;
					}
					p102 = p102 << 16;
					low4 = low4 + p102 | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low4,p102) < 0) {
						var ret7 = high4++;
						high4 = high4 | 0;
					}
					high4 = high4 + (haxe__$Int32_Int32_$Impl_$._mul(this_low3,b3.high) + haxe__$Int32_Int32_$Impl_$._mul(this_high3,b3.low) | 0) | 0;
					var this8 = new haxe__$Int64__$_$_$Int64(high4,low4);
					b2 = this8;
				}
				r = haxe__$Int64_Int64_$Impl_$.divMod(r,b2).quotient;
			}
			var mask3 = 65535;
			var al3 = v.low & mask3;
			var ah3 = v.low >>> 16;
			var bl3 = r.low & mask3;
			var bh3 = r.low >>> 16;
			var p003 = haxe__$Int32_Int32_$Impl_$._mul(al3,bl3);
			var p103 = haxe__$Int32_Int32_$Impl_$._mul(ah3,bl3);
			var p013 = haxe__$Int32_Int32_$Impl_$._mul(al3,bh3);
			var p113 = haxe__$Int32_Int32_$Impl_$._mul(ah3,bh3);
			var low5 = p003;
			var high5 = (p113 + (p013 >>> 16) | 0) + (p103 >>> 16) | 0;
			p013 = p013 << 16;
			low5 = low5 + p013 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(low5,p013) < 0) {
				var ret8 = high5++;
				high5 = high5 | 0;
			}
			p103 = p103 << 16;
			low5 = low5 + p103 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(low5,p103) < 0) {
				var ret9 = high5++;
				high5 = high5 | 0;
			}
			high5 = high5 + (haxe__$Int32_Int32_$Impl_$._mul(v.low,r.high) + haxe__$Int32_Int32_$Impl_$._mul(v.high,r.low) | 0) | 0;
			var this9 = new haxe__$Int64__$_$_$Int64(high5,low5);
			v = this9;
			var f = true;
			var l = tmp.keys();
			while(l.hasNext()) {
				var l1 = l.next();
				if(this.equals(k,l1)) {
					var a1 = tmp.h[l1.__id__];
					var high6 = a1.high + v.high | 0;
					var low6 = a1.low + v.low | 0;
					if(haxe__$Int32_Int32_$Impl_$.ucompare(low6,a1.low) < 0) {
						var ret10 = high6++;
						high6 = high6 | 0;
					}
					var this10 = new haxe__$Int64__$_$_$Int64(high6,low6);
					tmp.set(l1,this10);
					f = false;
				}
			}
			if(f) {
				tmp.set(k,v);
			}
			if(c[m - 1] == n) {
				break;
			}
			var _g33 = 0;
			var _g25 = m;
			while(_g33 < _g25) {
				var i7 = _g33++;
				if(c[i7] > 0) {
					c[0] = c[i7] - 1;
					var _g5 = 1;
					var _g4 = i7 + 1;
					while(_g5 < _g4) {
						var j1 = _g5++;
						c[j1] = 0;
					}
					c[i7 + 1] += i7 + 1 < m ? 1 : 0;
					break;
				}
			}
		}
		var k2 = tmp.keys();
		while(k2.hasNext()) {
			var k3 = k2.next();
			var a2 = tmp.h[k3.__id__];
			var this_high6 = 0;
			var this_low6 = 0;
			if(a2.high == this_high6 && a2.low == this_low6) {
				tmp.remove(k3);
			}
		}
		if(!tmp.keys().hasNext()) {
			var _g12 = [];
			var _g34 = 0;
			var _g26 = this.variables.length;
			while(_g34 < _g26) {
				var i8 = _g34++;
				_g12.push(0);
			}
			var this11 = new haxe__$Int64__$_$_$Int64(0,0);
			tmp.set(_g12,this11);
		}
		return tmp;
	}
	,fact: function(n) {
		var this_high = 0;
		var this_low = 0;
		var v = n.high - this_high | 0;
		v = v != 0 ? v : haxe__$Int32_Int32_$Impl_$.ucompare(n.low,this_low);
		if((n.high < 0 ? this_high < 0 ? v : -1 : this_high >= 0 ? v : 1) <= 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(0,1);
			return this1;
		} else {
			var this_high1 = 0;
			var this_low1 = 1;
			var high = n.high - this_high1 | 0;
			var low = n.low - this_low1 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(n.low,this_low1) < 0) {
				var ret = high--;
				high = high | 0;
			}
			var this2 = new haxe__$Int64__$_$_$Int64(high,low);
			var b = this.fact(this2);
			var mask = 65535;
			var al = n.low & mask;
			var ah = n.low >>> 16;
			var bl = b.low & mask;
			var bh = b.low >>> 16;
			var p00 = haxe__$Int32_Int32_$Impl_$._mul(al,bl);
			var p10 = haxe__$Int32_Int32_$Impl_$._mul(ah,bl);
			var p01 = haxe__$Int32_Int32_$Impl_$._mul(al,bh);
			var p11 = haxe__$Int32_Int32_$Impl_$._mul(ah,bh);
			var low1 = p00;
			var high1 = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
			p01 = p01 << 16;
			low1 = low1 + p01 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(low1,p01) < 0) {
				var ret1 = high1++;
				high1 = high1 | 0;
			}
			p10 = p10 << 16;
			low1 = low1 + p10 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(low1,p10) < 0) {
				var ret2 = high1++;
				high1 = high1 | 0;
			}
			high1 = high1 + (haxe__$Int32_Int32_$Impl_$._mul(n.low,b.high) + haxe__$Int32_Int32_$Impl_$._mul(n.high,b.low) | 0) | 0;
			var this3 = new haxe__$Int64__$_$_$Int64(high1,low1);
			return this3;
		}
	}
	,scale: function(a,n) {
		var tmp = new haxe_ds_ObjectMap();
		var k = a.keys();
		while(k.hasNext()) {
			var k1 = k.next();
			var this_high = n >> 31;
			var this_low = n;
			var b = a.h[k1.__id__];
			var mask = 65535;
			var al = this_low & mask;
			var ah = this_low >>> 16;
			var bl = b.low & mask;
			var bh = b.low >>> 16;
			var p00 = haxe__$Int32_Int32_$Impl_$._mul(al,bl);
			var p10 = haxe__$Int32_Int32_$Impl_$._mul(ah,bl);
			var p01 = haxe__$Int32_Int32_$Impl_$._mul(al,bh);
			var p11 = haxe__$Int32_Int32_$Impl_$._mul(ah,bh);
			var low = p00;
			var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
			p01 = p01 << 16;
			low = low + p01 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(low,p01) < 0) {
				var ret = high++;
				high = high | 0;
			}
			p10 = p10 << 16;
			low = low + p10 | 0;
			if(haxe__$Int32_Int32_$Impl_$.ucompare(low,p10) < 0) {
				var ret1 = high++;
				high = high | 0;
			}
			high = high + (haxe__$Int32_Int32_$Impl_$._mul(this_low,b.high) + haxe__$Int32_Int32_$Impl_$._mul(this_high,b.low) | 0) | 0;
			var this1 = new haxe__$Int64__$_$_$Int64(high,low);
			var v = this1;
			tmp.set(k1,v);
		}
		var k2 = tmp.keys();
		while(k2.hasNext()) {
			var k3 = k2.next();
			var a1 = tmp.h[k3.__id__];
			var this_high1 = 0;
			var this_low1 = 0;
			if(a1.high == this_high1 && a1.low == this_low1) {
				tmp.remove(k3);
			}
		}
		if(!tmp.keys().hasNext()) {
			var _g = [];
			var _g2 = 0;
			var _g1 = this.variables.length;
			while(_g2 < _g1) {
				var i = _g2++;
				_g.push(0);
			}
			var this2 = new haxe__$Int64__$_$_$Int64(0,0);
			tmp.set(_g,this2);
		}
		return tmp;
	}
	,compile: function(s) {
		var tmp = new haxe_ds_ObjectMap();
		var t = [];
		var _g = 0;
		var _g1 = this.variables;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			var f = true;
			var _g2 = 0;
			while(_g2 < t.length) {
				var r = t[_g2];
				++_g2;
				if(r == s1) {
					f = false;
				}
			}
			if(f) {
				t.push(s1);
			}
		}
		this.variables = [];
		var _g11 = 0;
		var _g3 = t.length;
		while(_g11 < _g3) {
			var i = _g11++;
			this.variables[i] = t[i];
		}
		var _g4 = [];
		var _g21 = 0;
		var _g12 = this.variables.length;
		while(_g21 < _g12) {
			var i1 = _g21++;
			_g4.push(0);
		}
		var a = _g4;
		if(new EReg("[a-zA-Z_\\$]","").match(s)) {
			var _g22 = 0;
			var _g13 = this.variables.length;
			while(_g22 < _g13) {
				var i2 = _g22++;
				if(s == this.variables[i2]) {
					a[i2] = 1;
					var this1 = new haxe__$Int64__$_$_$Int64(0,1);
					tmp.set(a,this1);
					return tmp;
				}
			}
		} else if(new EReg("[0-9]+","").match(s)) {
			var x = Std.parseInt(s);
			var this2 = new haxe__$Int64__$_$_$Int64(x >> 31,x);
			tmp.set(a,this2);
			return tmp;
		}
		throw new js__$Boot_HaxeError("unexpected string : " + s);
	}
	,equals: function(a,b) {
		var f = true;
		var _g1 = 0;
		var _g = this.variables.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(a[i] != b[i]) {
				f = false;
			}
		}
		return f;
	}
	,dumpIN: function(data) {
		var s = "";
		var list = [];
		var set = data.keys();
		while(set.hasNext()) {
			var set1 = set.next();
			list.push(set1);
		}
		list = this.sort(list,0);
		var b = false;
		var _g = 0;
		while(_g < list.length) {
			var k = list[_g];
			++_g;
			var a = [];
			var _g2 = 0;
			var _g1 = this.variables.length;
			while(_g2 < _g1) {
				var i = _g2++;
				var r = this.variables[i];
				r += k[i] == 1 ? "" : "^" + k[i];
				if(k[i] == 0) {
					continue;
				}
				a.push(r);
			}
			var t = "";
			var c = a.length - 1;
			var _g21 = 0;
			var _g11 = a.length;
			while(_g21 < _g11) {
				var i1 = _g21++;
				t += a[i1] + (c-- > 0 ? "*" : "");
			}
			var abs;
			var a1 = data.h[k.__id__];
			var this_high = 0;
			var this_low = 0;
			var v = a1.high - this_high | 0;
			v = v != 0 ? v : haxe__$Int32_Int32_$Impl_$.ucompare(a1.low,this_low);
			if((a1.high < 0 ? this_high < 0 ? v : -1 : this_high >= 0 ? v : 1) < 0) {
				var x = data.h[k.__id__];
				var high = ~x.high;
				var low = -x.low;
				if(low == 0) {
					var ret = high++;
					high = high | 0;
				}
				var this1 = new haxe__$Int64__$_$_$Int64(high,low);
				abs = this1;
			} else {
				abs = data.h[k.__id__];
			}
			var s1;
			var a2 = data.h[k.__id__];
			var this_high1 = 0;
			var this_low1 = 0;
			if(a2.high != this_high1 || a2.low != this_low1) {
				var a3 = data.h[k.__id__];
				var this_high2 = 0;
				var this_low2 = 0;
				var v1 = a3.high - this_high2 | 0;
				v1 = v1 != 0 ? v1 : haxe__$Int32_Int32_$Impl_$.ucompare(a3.low,this_low2);
				s1 = (a3.high < 0 ? this_high2 < 0 ? v1 : -1 : this_high2 >= 0 ? v1 : 1) > 0 ? b ? " + " : "" : " - ";
			} else {
				s1 = "";
			}
			var s2;
			if(t != "") {
				var this_high3 = 0;
				var this_low3 = 1;
				s2 = (abs.high != this_high3 || abs.low != this_low3 ? haxe__$Int64_Int64_$Impl_$.toString(abs) + "*" : "") + t;
			} else {
				s2 = haxe__$Int64_Int64_$Impl_$.toString(abs) + "";
			}
			s += s1 + s2;
			if(!b) {
				b = true;
			}
		}
		return s;
	}
	,sort: function(list,k) {
		if(k >= this.variables.length) {
			return list;
		}
		var tmp = [];
		var max = 0;
		var _g = 0;
		while(_g < list.length) {
			var l = list[_g];
			++_g;
			max = l[k] > max ? l[k] : max;
		}
		var i = 0;
		var n = max;
		while(i < list.length) {
			var tmp_ = [];
			var _g1 = 0;
			while(_g1 < list.length) {
				var l1 = list[_g1];
				++_g1;
				if(l1[k] == n) {
					tmp_.push(l1);
					++i;
				}
			}
			tmp_ = this.sort(tmp_,k + 1);
			var _g2 = 0;
			while(_g2 < tmp_.length) {
				var l2 = tmp_[_g2];
				++_g2;
				tmp.push(l2);
			}
			--n;
		}
		return tmp;
	}
};
String.__name__ = true;
Array.__name__ = true;
haxe_ds_ObjectMap.count = 0;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
haxe__$Int32_Int32_$Impl_$._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
main_Main.main();
})();
